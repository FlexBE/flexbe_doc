## For instruction on writing tutorials
## http://www.ros.org/wiki/WritingTutorials
####################################
##FILL ME IN
####################################
## for a custom note with links:
## note =This tutorial assumes you have completed all of the [[flexbe/Tutorials|basic tutorials]] for FlexBE.
## for the canned note of "This tutorial assumes that you have completed the previous tutorials:" just add the links
## note.0=
## descriptive title for the tutorial
## title =Developing Actionlib States
## multi-line description to be displayed in search
## description =States based on [[actionlib]] actions are very common and typically share a similar pattern. This tutorial presents how to easily create them.
## the next tutorial description (optional)
## next =
## links to next tutorial (optional)
## next.0.link=
## next.1.link=
## what level user is this tutorial for
## level= IntermediateCategory
## keywords =
####################################
<<IncludeCSTemplate(TutorialCSHeaderTemplate)>>

<<TableOfContents(4)>>

== Motivation ==

FlexBE states are the high-level building blocks from which behaviors are constructed and are supposed to interface with the capabilities of your robot system. [[actionlib]] provides such an interface where robot capabilities can be provided by ROS nodes implementing an action server and states can then access them by acting as an action client. The interface is designed for long-term (longer than one update cycle) actions as it is non-blocking and optionally provides feedback while being executed. This makes it a perfect interface to be used along with FlexBE and it is recommended to base your states on action interfaces whenever they do something more complex than just subscribing to a topic.

== Action Client ==

This tutorial is based on the [[https://github.com/pschillinger/flexbe_project_behaviors/blob/master/PROJECT_flexbe_states/src/PROJECT_flexbe_states/example_action_state.py|ExampleActionState]] which is one of the example states automatically created when you run the ''create_repo'' script.

First, make sure you import the action client proxy and the required message types of the action interface:
{{{
#!python
from flexbe_core.proxy import ProxyActionClient
# example import of required action
from chores.msg import DoDishesAction, DoDishesGoal
}}}

=== Declaration ===

It is recommended to create the action client in the constructor of your state as this will check the availability of the action server before starting the behavior and thus, reduce the risk for runtime failure.

In order to declare the required action client, add the following code to the constructor:
{{{
#!python
self._topic = 'do_dishes'
self._client = ProxyActionClient({self._topic: DoDishesAction})
}}}

=== Sending a Goal ===

Typically, a state sends its goal once when it becomes active in order to trigger a certain action. Thus, create and send the action goal in the ''on_enter'' callback of your state. You can access userdata input keys here as required.
{{{
#!python
goal = DoDishesGoal()
goal.dishwasher_id = userdata.dishwasher

self._error = False
try:
	self._client.send_goal(self._topic, goal)
except Exception as e:
	Logger.logwarn('Failed to send the DoDishes command:\n%s' % str(e))
	self._error = True
}}}

For robustness, it is recommended to embed the action call in a try/catch block in case there are any problems during runtime. The variable {{{self._error}}} can be used in the {{{execute}}} function to return a failure outcome if any problems occured:

{{{
#!python
# Check if the client failed to send the goal.
if self._error:
	return 'command_error'
}}}

=== Checking for Result ===

Finally, in the execution loop, you can check if the action has already finished and evaluate its result. You can also store relevant parts of its result in the userdata.

{{{
#!python
if self._client.has_result(self._topic):
	result = self._client.get_result(self._topic)
	dishes_cleaned = result.total_dishes_cleaned

	userdata.cleaned = dishes_cleaned

	if dishes_cleaned > self._dishes_to_do:
		return 'cleaned_enough'
	else:
		return 'cleaned_some'
}}}

You can also access the result status of the action call if there is no notation of success provided by the result message itself:
{{{
#!python
if self._client.has_result(self._topic):
	status = self._client.get_state(self._topic)
	if status == GoalStatus.SUCCEEDED:
		return 'success'
	elif status in [GoalStatus.PREEMPTED, GoalStatus.REJECTED, GoalStatus.RECALLED, GoalStatus.ABORTED]:
		Logger.logwarn('Action failed: %s' % str(status))
		return 'failed'
}}}

Note that you need to import the GoalStatus message provided by actionlib for this:
{{{
from actionlib_msgs.msg import GoalStatus
}}}


## AUTOGENERATED DO NOT DELETE
## TutorialCategory
## FILL IN THE STACK TUTORIAL CATEGORY HERE
